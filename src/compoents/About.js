import React from 'react';
import "../styles/About.css"

const About = () => {
    const  content = "Field Access:\n" +
        "\n" +
        "Removed the field map\n" +
        "- Correspondingly, I removed this IR so I don't have to jump to 2nd slot for field map: %1 = %x0 + 8\n" +
        "  I can directly load the object and access the field\n" +
        "  No longer need to go to field address and store @fieldsMap\n" +
        "  removed the IR:\n" +
        "  %1 = %x0 + 8\n" +
        "  store(%1, @fieldsA)\n" +
        "Method calls\n" +
        "\n" +
        "No longer need to check if the method lookup succeeds\n" +
        "What's included\n" +
        "working1.txt\n" +
        "- This included a source code that can be run without any type errors.\n" +
        "failed1.txt\n" +
        "- This included a source code that tries to access a field that is not defined in the class.\n" +
        "working2.txt\n" +
        "- This included a source code that can be run without any type errors.\n" +
        "failed2.txt\n" +
        "- This included a source code that tries print a class\n" +
        "`;"

    return (
        <div className="about-container" style={{ lineHeight: '1.6', maxWidth: '800px', margin: 'auto', padding: '20px' }}>
            <h1 style={{ textAlign: 'center' }}>About</h1>
            <h3>Why is it called YesCompiler?</h3>
            <p> Because Implementing a compiler is really hard, and everytime you fixed something you should yell "Yes!"</p>
            <h3>Field Access:</h3>
            <p>Removed the field map<br />
                - Correspondingly, I removed this IR so I don't have to jump to the 2nd slot for field map: <code>%1 = %x0 + 8</code><br />
                I can directly load the object and access the field<br />
                No longer need to go to field address and store <code>@fieldsMap</code><br />
                removed the IR:<br />
                <code>%1 = %x0 + 8</code><br />
                store(<code>%1</code>, <code>@fieldsA</code>)</p>

            <h3>Method calls</h3>
            <p> - No longer need to check if the method lookup succeeds</p>

            <h3>What's included</h3>
            <p><strong>working1.txt</strong><br />
                - This included a source code that can be run without any type errors.</p>
            <p><strong>failed1.txt</strong><br />
                - This included a source code that tries to access a field that is not defined in the class.</p>
            <p><strong>working2.txt</strong><br />
                - This included a source code that can be run without any type errors.</p>
            <p><strong>failed2.txt</strong><br />
                - This included a source code that tries to print a class</p>
            {/*<h3>Type-based optimization:</h3>*/}
            {/*<h5>Tag checks</h5>*/}
            {/*<p>*/}
            {/*    Removed tag checks for field access and method calls.*/}
            {/*</p>*/}
            {/*<h5>Field Access</h5>*/}
            {/*<p>*/}
            {/*    Removed tag checks for field access and method calls.*/}
            {/*</p>*/}
            {/*<p>*/}
            {/*    For instance, in example2.txt, Class A has a method that has 2 variables with the same arithmetic operations. With the same arithmetic operations, the same temporary variable has been used. In class B, it has a method that has 2 variables with similar arithmetic operations:*/}
            {/*    <br />*/}
            {/*    <code>x = (3 * 5)</code>*/}
            {/*    <br />*/}
            {/*    <code>z = ((5 * 3) * 2)</code>*/}
            {/*    <br />*/}
            {/*    'z' can use the temporary variable generated by 'x', so it can be just <code>z = (%x0 * 2)</code>.*/}
            {/*</p>*/}
        </div>
    );
};

export default About;
